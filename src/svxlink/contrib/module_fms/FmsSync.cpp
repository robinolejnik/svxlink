#include <iostream>
#include "FmsSync.h"

using namespace std;

FmsSync::FmsSync(unsigned baudrate, unsigned sample_rate) : baudrate(baudrate), sample_rate(sample_rate), shift_pos(sample_rate / 2), pos(0), was_mark(false), rxstate(0), rxbitstream(0), rxbitcount(0) {
}

FmsSync::~FmsSync(void) {
}

char FmsSync::fms_is_crc_correct(uint64_t message) {
  int i;
  char crc[7];
  char doinvert;

  // Initialize the crc to 0s
  for (i=0; i<7; ++i) {
    crc[i] = 0;
  }

  for (i=0; i<48; ++i) {
    // update the running CRC
    // The implementation is not the most performant one but it suffices for my basic understanding of CRCs.
    // Code generated by http://ghsi.de/CRC/index.php
    // ==========================================================================
    // CRC Generation Unit - Linear Feedback Shift Register implementation
    // (c) Kay Gorontzi, GHSi.de, distributed under the terms of LGPL
    // ==========================================================================
    //std::cout << "FMS CRC BIT: "%1x\n", ((message >> (16+i)) & 1));
    doinvert = ((message >> (16+i)) & 1) ^ crc[6];         // XOR required?

    crc[6] = crc[5] ^ doinvert;
    crc[5] = crc[4];
    crc[4] = crc[3];
    crc[3] = crc[2];
    crc[2] = crc[1] ^ doinvert;
    crc[1] = crc[0];
    crc[0] = doinvert;

    //fms_print_crc(crc);
  }

  for (i=0; i<7; ++i) {
    if (crc[i]) {
      //fms_print_crc(crc);
      return 0;
    }
  }
  return 1;
}

int FmsSync::writeSamples(const float *samples, int len) {
  for (int i=0; i<len; ++i) {
    pos += baudrate;
    bool is_mark = (samples[i] > 0);
    if (is_mark != was_mark) {
      int err = shift_pos - pos;
      pos += err / 5;
    }
    was_mark = is_mark;

    if (pos >= sample_rate) {
      bool bit = !is_mark;
      rxstate = ((rxstate << 1) & 0x000FFFFE) | bit;
      if ((rxstate & 0x0007FFFF) == 0x7FF1A) {
        rxbitstream = 0;
        rxbitcount = 1;
      }
      if(rxbitcount>=1) {
        rxbitstream = (rxbitstream >> 1) | ((uint64_t) bit << 63);
        rxbitcount++;
        if(rxbitcount==49) {
          if(!fms_is_crc_correct(rxbitstream)) {
            std::cout << "crc error" << std::endl;
            i = 0;
            uint64_t msg = rxbitstream;
            while (i <= 47) {
              if (fms_is_crc_correct(msg ^ (1 << (i+16)))) {
                std::cout << "FMS was able to correct a one bit error by swapping bit %d Original packet: " << i << std::endl;
                //fms_disp_packet(s->l2.fmsfsk.rxbitstream);
                rxbitstream = (msg ^ (1 << (i+16))) | 1; // lowest bit set means that the CRC has been corrected by us
                break;
              }
              i++;
            }
            if (i == 48) {
              std::cout << "FMS: unable to correct CRC error" << std::endl;
            }
          }
          packetReceived(rxbitstream);
          rxbitcount = 0; // Reset counter, meaning "no valid SYNC yet"
          rxstate = 0;
        }
      }

      pos -= sample_rate;
    }
  }
  return len;
}

void FmsSync::flushSamples(void) {
  sourceAllSamplesFlushed();
}
